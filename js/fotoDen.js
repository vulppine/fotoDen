/* eslint-env browser */

// fotoDen v0.0.1
//
// The front-end for a photo gallery.
//
// Copyright (c) 2021 Flipp Syder
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// autogenerated by fotoDen tool, touch at your own risk

// const BaseURL = {{.JSLocation}} -- UNCOMMENT THIS IF USING fotoDen TOOL, OR IF PACKAGING WITH fotoDen TOOL
const BaseURL = 'https://localhost:8080' // development purposes only, of course

// global variables

let isMobile

// configuration

let websiteTitle
let workingDirectory
let photoStorageURLBase
let photoExtension
let displayImageFrom
let imageLargeDir
let imageThumbDir
let imageSrcDir
let imageNamePrefix

function setConfig () {
  const newURL = new URL(BaseURL)
  const newPath = newURL.pathname.split('/')

  if (newPath[newPath.length] === '') {
    workingDirectory = newPath[newPath.length - 1]
    newPath.pop()
    newPath.push('config.json')
    newURL.pathname = newPath.join('/')
  } else {
    workingDirectory = newPath[newPath.length]
    newPath.push('config.json')
    newURL.pathname = newPath.join('/')
  }

  return new Promise((resolve, reject) => {
    const config = ajaxGETJSON(newURL)

    config.then((json) => { readConfig(json); resolve() },
      (status) => { console.error('Error: No fotoDenConfig.json file found! Aborting!'); reject(status) }
    )
  })
}

function readConfig (info) {
  workingDirectory = info.WorkingDirectory
  photoStorageURLBase = info.PhotoURLBase
  photoExtension = info.PhotoExtension
  displayImageFrom = info.DisplayImageFrom
  imageLargeDir = info.ImageLargeDir
  imageThumbDir = info.ImageThumbDir
  imageSrcDir = info.ImageSrcDir

  switch (displayImageFrom) {
    case 'src':
      displayImageFrom = imageSrcDir
      break
    case 'large':
      displayImageFrom = imageLargeDir
      imageNamePrefix = 'large_'
      break
    default:
      console.log('Image display directory unknown, setting to thumb')
      displayImageFrom = imageThumbDir
  }
}

// generic functions

function setCurrentURLParam (param, value) {
  const newURL = new URL(document.URL)
  const newURLParams = new URLSearchParams(newURL.search)

  newURLParams.set(param, value)
  newURL.search = newURLParams.toString()

  return newURL
}

function ajaxGETJSON (url) {
  const request = new XMLHttpRequest()

  return new Promise((resolve, reject) => {
    request.onreadystatechange = () => {
      if (request.readyState === 4) {
        if (request.status === 200) {
          resolve(JSON.parse(request.response))
        } else {
          reject(request.status)
        }
      }
    }
    request.open('GET', url)
    request.send()
  })
}

function setError (errText) {
  document.getElementById('errorBox').setAttribute('style', 'display: block')
  document.getElementById('error').innerHTML = errText
}

// setTitle
//
// Takes an array of strings, separates them via a separator string and adds
// the website title at the end.

function setTitle (items) {
  items.push(websiteTitle)
  document.title = items.join(' - ')
}

function getFolderURL (level) {
  const folderURL = new URL(document.URL)
  const folderPath = folderURL.pathname.split('/').slice(0, folderURL.pathname.split('/').length - 1) // knock off any index.htmls or nulls right off the bat;
  const rootDirectoryLoc = folderPath.indexOf(workingDirectory)

  folderURL.search = ''

  if (folderPath.length - level < folderPath.length - rootDirectoryLoc) {
    console.error('Error: attempted to go deeper than workingDirectory, aborting!')
  } else {
    folderURL.pathname = folderPath.slice(0, folderPath.length - level).concat(['']).join('/') // folders should really have a default page file name
    folderURL.href = folderURL.origin + folderURL.pathname + folderURL.search // had an issue with this, so i'm forcing it
    return folderURL
  }
}

function getPageInfo (url) {
  const search = new URLSearchParams(url.search)

  return {
    index: search.get('index'),
    page: search.get('page')
  }
}

// photoViewer

/* photoObject
 *
 * The main idea is that the photo.html page should be
 * a static page that's linked from the generated
 * album pages, if somebody wants a bigger view of a photo
 * but they also want to link directly back to the site
 *
 * Most of the design of the display is already within
 * the HTML file, this lirary's task is to just give it
 * the actual functionality it requires.
 *
 */

function makePhotoURL (photoName, dir) {
  if (photoStorageURLBase === 'local' || photoStorageURLBase === '') {
    return getAlbumURL() + '/' + dir + '/' + photoName
  } else {
    const newURL = new URL(document.URL)
    const newURLPathArray = newURL.pathname.split('/')
    const rootDirectoryLoc = newURLPathArray.indexOf(workingDirectory)

    return photoStorageURLBase + newURLPathArray.slice(rootDirectoryLoc, newURLPathArray.length - 1).join('/') + '/' + dir + '/' + photoName
  }
}

function PhotoObject () {
  this.name = ''
  this.album = '' // we get this from folderInfo.json
  this.index = getPageInfo(new URL(document.URL)).index
  this.canvas = null
  this.blobURL = null
  this.cloudURL = null
}

/* photoViewer
 *
 * This has everything we need in terms of visuals.
 * The photo to view, the arrows to go to the next
 * and previous photo are the basic bits.
 *
 * TODO: Add a carousel at the bottom
 */

const PhotoViewers = []

class PhotoViewer {
  constructor (container) {
    this.container = container
    this.name = container.getElementsByClassName('photoName')[0].innerHTML
    const albumInfo = ajaxGETJSON(getAlbumURL() + 'folderInfo.json')
    const photo = new PhotoObject()

    albumInfo.then((json) => {
      if (isNaN(parseInt(photo.index))) {
        photo.index = 0
      }
      photo.name = json.ItemsInFolder[photo.index]
      photo.album = json.FolderName
      this.setAlbum(photo.album)

      if (parseInt(photo.index) === json.ItemsInFolder.length - 1) {
        this.setPrev(setCurrentURLParam('index', (parseInt(photo.index) - 1)))
        this.setNext(null)
      } else if (parseInt(photo.index) === 0) {
        this.setPrev(null)
        this.setNext(setCurrentURLParam('index', 1))
      } else {
        this.setPrev(setCurrentURLParam('index', (parseInt(photo.index) - 1)))
        this.setNext(setCurrentURLParam('index', (parseInt(photo.index) + 1)))
      }

      setTitle([photo.name, photo.album])
      this.setPhoto(json.ItemsInFolder[photo.index])
    }, (status) => {
      setTitle([status])
      setError('An error occurred while attempting to get the album information: ' + status)
    })
  }

  setAlbum (name) {
    document.getElementsByClassName('folderInfoLink')[0].innerHTML = name
    document.getElementsByClassName('folderInfoLink')[0].href = getAlbumURL().toString()
  }

  setPhoto (image) {
    document.getElementsByClassName('mainPhoto')[0].src = makePhotoURL(imageNamePrefix + image, displayImageFrom)
    document.getElementsByClassName('downloadButton')[0].href = makePhotoURL(imageNamePrefix + image, displayImageFrom)
  }

  setNext (URL) {
    const navNext = document.getElementsByClassName('navNext')[0]

    if (URL === null) {
      navNext.removeAttribute('href')
      navNext.setAttribute('class', 'buttonNull')
    } else {
      navNext.href = URL
    }
  }

  setPrev (URL) {
    const navPrev = document.getElementsByClassName('navPrev')[0]

    if (URL === null) {
      navPrev.removeAttribute('href')
      navPrev.setAttribute('class', 'buttonNull')
    } else {
      navPrev.href = URL
    }
  }
}

// albums

function getAlbumURL () {
  return getFolderURL(0)
}

// AlbumViewer
//
// AlbumViewers are containers for album-type pages.
// They take in a specific JSON object, and use its info in order to display the album
// within the current folder (specified by the URL of the folder).
//
// Functions within an AlbumViewer include generating navigation pages,
// and calling the thumbnail generator to create thumbnails according
// to the current items in the folder, from ImageThumbDir from the current website's config.

const AlbumViewers = []

// constructor for AlbumViewer

class AlbumViewer {
  constructor (container) {
    this.container = container
    this.imagesPerPage = 50 // turn this into a 'current settings' var - perhaps not? that could be abused (e.g., set imagesPerPage to 1000000 to overflow)
    this.currentPage = parseInt(getPageInfo(new URL(document.URL)).page)

    if (isNaN(this.currentPage)) { this.currentPage = 1 }
    const albumInfo = ajaxGETJSON(getAlbumURL() + 'folderInfo.json')

    albumInfo.then((json) => {
      this.info = json
      this.photos = json.ItemsInFolder
      this.maxPhotos = json.ItemsInFolder.length
      this.pageAmount = Math.ceil(this.maxPhotos / this.imagesPerPage)
      if (this.container.getElementsByClassName('folderLinks').length === 1) {
        this.folderViewer = this.container.getElementsByClassName('folderLinks')[0]
      };

      this.container.getElementsByClassName('folderName')[0].innerHTML = this.info.FolderName
      setTitle([this.info.FolderName])

      if (this.info.supFolderName !== '') {
        this.container.getElementsByClassName('folderUp')[0].innerHTML = this.info.SupFolderName
        this.container.getElementsByClassName('folderUp')[0].href = getFolderURL(1).toString()
      } else {
        this.container.getElementsByClassName('folderSubtitle').setAttribute('style', 'display: none')
      }

      if (isMobile) {
        this.container.getElementsByClassName('albumThumbnailContainer')[0].addEventListener('scroll', () => {
          const currentScroll = this.container.getElementsByClassName('albumThumbnailContainer')[0].scrollTop
          const maxHeight = this.container.getElementsByClassName('albumThumbnailContainer')[0].scrollHeight

          if (currentScroll > (maxHeight - (maxHeight * 0.25))) {
            if (this.currentPage !== Math.ceil(this.maxPhotos / this.imagesPerPage)) {
              this.currentPage++
              this.populate()
            }
          }
        })
      }

      this.update()
    }, (status) => {
      setTitle([status])
      setError('error initializing AlbumViewer: ' + status)
    })
  }

  createThumbnail (photoIndex, photoName) {
    const thumbnailContainer = document.createElement('div')
    const thumbnail = new Image()
    const thumbnailAnchor = document.createElement('a')
    const thumbnailLink = new URL(document.URL)
    const thumbnailLinkParams = new URLSearchParams(thumbnailLink)

    thumbnailLinkParams.set('index', photoIndex)
    thumbnailLink.pathname = getAlbumURL().pathname.split('/').slice(0, getAlbumURL().pathname.split('/').length - 1).concat(['photo.html']).join('/')
    thumbnailLink.search = thumbnailLinkParams.toString()

    thumbnailContainer.appendChild(thumbnailAnchor)
    thumbnailContainer.setAttribute('class', 'albumThumbnail')

    thumbnailAnchor.appendChild(thumbnail)
    thumbnailAnchor.setAttribute('href', thumbnailLink.toString())
    thumbnailAnchor.setAttribute('class', 'albumThumbnailLink')

    thumbnail.setAttribute('class', 'albumThumbnailImage')
    thumbnail.setAttribute('src', imageThumbDir + '/thumb_' + photoName)

    return thumbnailContainer
  }

  populate () {
    let index = this.imagesPerPage * (this.currentPage - 1)

    while (index < this.maxPhotos) {
      if (index === (this.imagesPerPage * (this.currentPage - 1)) + this.imagesPerPage) {
        break
      } else {
        this.container.getElementsByClassName('albumThumbnailContainer')[0].appendChild(this.createThumbnail(index, this.photos[index]))
      }
      index++
    }
  }

  setNavPageLinks () {
    const navPrev = this.container.getElementsByClassName('navPrev')[0]
    const navNext = this.container.getElementsByClassName('navNext')[0]

    if (this.currentPage === 1) {
      navPrev.setAttribute('class', 'navPrev buttonNull')
      navPrev.removeAttribute('href')
      navNext.href = setCurrentURLParam('page', (this.currentPage + 1))
    } else if (this.currentPage === this.pageAmount) {
      navPrev.href = setCurrentURLParam('page', (this.currentPage - 1))
      navNext.setAttribute('class', 'navNext buttonNull')
      navNext.removeAttribute('href')
    } else {
      navPrev.href = setCurrentURLParam('page', (this.currentPage - 1))
      navNext.href = setCurrentURLParam('page', (this.currentPage + 1))
    }

    for (let i = 1; i < this.pageAmount + 1; i++) {
      const newAnchor = document.createElement('a')
      const newURL = getAlbumURL()

      newAnchor.innerHTML = i

      if (i === this.currentPage) {
        newAnchor.setAttribute('class', 'albumPageLinkActive')
      } else {
        newURL.search = '?page=' + i
        newAnchor.href = newURL.toString()
        newAnchor.setAttribute('class', 'albumPageLink')
      };

      this.container.getElementsByClassName('navPage')[0].appendChild(newAnchor)
    }
  }

  update () {
    const currentThumbnails = this.container.getElementsByClassName('albumThumbnail')
    const currentThumbnailAmount = currentThumbnails.length
    for (let i = 0; i < currentThumbnailAmount; i++) {
      currentThumbnails.item(0).remove()
    };

    if (this.folderViewer !== null) {
      if (this.currentPage === 1 && this.info.SubfolderShortNames[0] !== undefined) {
        // todo: put something here?
      } else {
        this.folderViewer.setAttribute('style', 'display: none')
      };
    };

    this.setNavPageLinks()
    this.populate()
  }
}

/* folderViewer
 *
 * Generic sub-folder viewer.
 *
 */

// Constructor for a FolderViewer
//
// Allows access to a container that contains a FolderViewer.
// Includes access for setting any current titles, compared to an AlbumViewer which auto-sets.
// If the current FolderType is 'folder', it will auto-set the style to a full version on init instead of the shorter, smaller version seen in albums.

const FolderViewers = []

class FolderViewer {
  constructor (container) {
    this.container = container
    this.name = container.getElementsByClassName('folderName')[0]
    this.folderUp = container.getElementsByClassName('folderUp')[0]
    this.folderLinks = container.getElementsByClassName('folderLinks')[0]
    this.style = ''
    const folderInfo = ajaxGETJSON(getFolderURL(0) + 'folderInfo.json')

    folderInfo.then((info) => {
      this.info = info
      this.type = info.FolderType
      console.log('Success!')
      if (info.FolderType !== 'album') {
        this.name.innerHTML = info.FolderName
        if (info.SupFolderName !== '') {
          this.folderUp.innerHTML = info.SupFolderName
          this.folderUp.href = getFolderURL(1).toString()
        } else {
          this.container.getElementsByClassName('folderSubtitle')[0].setAttribute('style', 'display: none')
        }
      }
      this.populate()
      setTitle([info.FolderName])
    }, (status) => {
      document.title = status + ' - vulppine'
      setError('error initializing FolderViewer: ' + status)
    })
  }

  makeFolderLink (folderShortName) {
    const folderLinkContainer = document.createElement('div')
    const folderLink = getFolderURL(0).toString() + folderShortName + '/'
    const folderInfo = ajaxGETJSON(folderLink + 'folderInfo.json')
    const folderInfoContainer = document.createElement('div')
    const folderItemCount = document.createElement('div')
    const folderAnchor = document.createElement('a')
    const folderThumbnail = new Image()

    folderAnchor.setAttribute('class', 'folderLink')
    folderLinkContainer.setAttribute('class', 'folderLinkContainer')
    folderInfoContainer.setAttribute('class', 'folderInfoContainer')
    folderItemCount.setAttribute('class', 'folderItemCount')
    folderThumbnail.setAttribute('class', 'folderThumbnail')

    folderAnchor.appendChild(folderLinkContainer)
    folderLinkContainer.appendChild(folderThumbnail)
    folderLinkContainer.appendChild(folderInfoContainer)
    folderInfoContainer.appendChild(folderItemCount)
    folderInfo.then((info) => {
      if (info.FolderThumbnail === true) {
        folderThumbnail.src = info.FolderShortName + '/thumb' + photoExtension
      } else {
        folderThumbnail.src = BaseURL + 'thumb.png'
      };

      if (info.ItemsInFolder != null) {
        const newDiv = document.createElement('div')
        newDiv.innerHTML = 'Photos: ' + info.ItemsInFolder.length // remember, this is still photo oriented...
        folderItemCount.appendChild(newDiv)
      };

      if (info.SubfolderShortNames.length > 0) {
        const newDiv = document.createElement('div')
        newDiv.innerHTML = 'Folders: ' + info.SubfolderShortNames.length
        folderItemCount.appendChild(newDiv)
      }

      const name = document.createElement('span')
      name.innerHTML = info.FolderName
      folderInfoContainer.insertBefore(name, folderItemCount)
      folderAnchor.href = folderLink
    })

    return folderAnchor
  }

  populate () {
    for (let i = 0; i < this.info.SubfolderShortNames.length; i++) {
      this.folderLinks.appendChild(this.makeFolderLink(this.info.SubfolderShortNames[i]))
    };
  }
}

/* Page initilization
 *
 * Checks if we're in a photo viewer,
 * otherwise attempts to initialize both the folders and the album items.
 */

function pageInit () {
  const mobileCheck = window.matchMedia('(pointer: coarse)')
  if (mobileCheck.matches) { isMobile = true }
  const success = setConfig()

  success.then(() => {
    if (document.getElementById('PhotoViewer')) {
      const photoViewer = new PhotoViewer(document.getElementById('PhotoViewer'))
      PhotoViewers.push(photoViewer)
    } else {
      if (document.getElementById('FolderViewer')) {
        const folderViewer = new FolderViewer(document.getElementById('FolderViewer'))
        FolderViewers.push(folderViewer)
      }
      if (document.getElementById('AlbumViewer')) {
        const albumViewer = new AlbumViewer(document.getElementById('AlbumViewer'))
        AlbumViewers.push(albumViewer)
      }
    };
  }, (status) => {
    setTitle([status])
    setError('error getting config: ' + status)
  })
};

window.onload = pageInit()
